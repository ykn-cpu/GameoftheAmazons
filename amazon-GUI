#include<iostream>
#include<cmath>
#include<vector>
#include <cstdlib>
#include <fstream>
#include <ctime>
#include<sstream>
#include<string>
#include<graphics.h>
#include<conio.h>
#include<algorithm>
#include <mmsystem.h>
#include<queue>
#include<chrono>
#pragma comment(lib, "winmm.lib")
using namespace std;
using namespace chrono;
using std::chrono::duration_cast;
using std::chrono::milliseconds;
steady_clock::time_point startTime;
const int GRIDSIZE = 8;
int gridInfo[GRIDSIZE][GRIDSIZE];
const int grid_black = 1;
const int grid_white = -1;
const int obstacle = 2;
int currentcolor;
int mycolor; // äººæœºæ¨¡å¼ä¸‹ï¼Œç©å®¶æ‰§å­é¢œè‰²
int dx[8] = { -1,-1,-1,0,0,1,1,1 };
int dy[8] = { -1,0,1,-1,1,-1,0,1 };
int hoverr = -1, hoverc = -1;//é¼ æ ‡æ‚¬åœçš„è¡Œä»¥åŠåˆ—
vector<vector<int>>legalmove;//æ‰€æœ‰åˆæ³•æ£‹å­è·¯å¾„
vector<vector<int>>legalarrow;//æ‰€æœ‰åˆæ³•å°„ç®­è·¯å¾„
int destx, desty = 0;//è®°å½•å½“å‰é€‰å®šçš„ç›®æ ‡æ£‹å­ä½ç½®
//updateï¼šå›¾å½¢ç•Œé¢é¼ æ ‡é€‰æ‹©èœå•
// æ£‹ç›˜å·¦ä¸Šè§’åæ ‡å’Œæ ¼å­å¤§å°
const int BOARD_X = 50, BOARD_Y = 90, CELL_SIZE = 60;//æ£‹ç›˜å·¦ä¸Šè§’ç‚¹çš„åæ ‡ï¼Œå•ä¸ªæ ¼å­è¾¹é•¿
const int lowerboundary = BOARD_X + GRIDSIZE * CELL_SIZE;//æ£‹ç›˜ä¸‹è¾¹ç•Œ
const int rightboundary = BOARD_Y + GRIDSIZE * CELL_SIZE;//æ£‹ç›˜å³è¾¹ç•Œ
int hoverbutton = -1;
vector<wstring> icons{ L"â™»ï¸", L"ğŸ“‚", L"âŒ" };//ä¸‰ä¸ªèœå•åŠŸèƒ½çš„æ ‡è¯†ç¬¦
struct button {
    int x, y, w, h;//æŒ‰é’®å·¦ä¸Šè§’åæ ‡x,yï¼Œå®½wï¼Œé«˜h
    wstring text;//æŒ‰é’®çš„æ–‡å­—
};
vector<button>buttons{
    {180,140,180,50,L"æ–°å¼€å§‹"},
    {180,220,180,50,L"è¯»ç›˜"},{180,300,180,50,L"é€€å‡º"}
};
void drawbackground() {
    for (int i = 0; i < 700; i += 2) {
        int g = 140 + (i * 80) / 700; // æ¸å˜çš„ç»¿è‰²åˆ†é‡
        int r = 80 + (i * 80) / 700;
        int b = 80 + (i * 80) / 700;
        setfillcolor(RGB(r, g, b));
        solidrectangle(0, i, 700, i + 2);
    }
}
void drawmenu(int hoverbutton) {
    drawbackground();
    setbkcolor(RGB(128, 128, 128));
    wstring ws = L"ä¸»èœå•";
    settextstyle(30, 0, _T("å¾®è½¯é›…é»‘"));
    setbkmode(TRANSPARENT);
    settextcolor(BLUE);
    outtextxy(230,80,ws.c_str());
    for (int i = 0; i < buttons.size(); i++) {
            // æ‚¬åœé«˜äº®
            if (i == hoverbutton) {
                setfillcolor(RGB(220, 220, 100)); // é»„è‰²é«˜äº®
            }
            else {
                setfillcolor(RGB(210, 210, 210)); // æ™®é€šç°è‰²
            }
            roundrect(buttons[i].x, buttons[i].y, buttons[i].x + buttons[i].w, 
                buttons[i].y + buttons[i].h,30,30);
            fillroundrect(buttons[i].x, buttons[i].y, buttons[i].x + buttons[i].w,
                buttons[i].y + buttons[i].h, 30, 30);
            settextstyle(30, 0, _T("å¾®è½¯é›…é»‘"));
            setbkmode(TRANSPARENT);
            settextcolor(BLACK);
            outtextxy(buttons[i].x+50, buttons[i].y+10, buttons[i].text.c_str());
            outtextxy(buttons[i].x+10, buttons[i].y+10, icons[i].c_str());
    }
}
void drawstatusbar(bool cansave) {//å¢åŠ ä¸€ä¸ªå‚æ•°ï¼Œè¡¨ç¤ºåªæœ‰äººç±»æœªé€‰å®šæˆ–è€…aièµ°æ­¥å®Œæˆæ—¶åˆ»å…è®¸å­˜ç›˜
    //çŠ¶æ€æ x=0,y=650,w=600,h=80

    /*setfillcolor(RGB(240, 240, 240));
    solidrectangle(0, 600, 600, 700);*/
    int savex = 440, savey = 630, savew = 120, saveh = 40;
    int exitx = 300, exity = 630, exitw = 120, exith = 40;
    setfillcolor(YELLOW);
    if(cansave)fillroundrect(savex, savey, savew + savex, savey + saveh, 20, 20);
    fillroundrect(exitx, exity, exitw + exitx, exity + exith, 20, 20);
    settextstyle(24, 0, _T("å¾®è½¯é›…é»‘"));
    settextcolor(BLUE);
    if(cansave)outtextxy(savex+40, savey+10, L"ğŸ“‚å­˜ç›˜");//åªæœ‰å…è®¸å­˜ç›˜æ—¶ï¼Œç”»å‡ºå­˜ç›˜æŒ‰é’®
    outtextxy(exitx + 40, exity + 10, L"âŒé€€å‡º");
}
//void drawbackground() {
//    for (int i =0; i <600; i += 2) {
//        setfillcolor(RGB(80 + (600-i) / 10, 80 + (600-i) / 10, 80 + (600-i) / 10));
//        solidrectangle(0, i, 600, i + 2);
//    }
//}
int selectmenu() {
    drawmenu(hoverbutton);
    while (1) {
        ExMessage msg;
        if (peekmessage(&msg, EX_MOUSE)) {
            if (msg.message == WM_MOUSEMOVE) {
                hoverbutton = -1;
                for (int i = 0; i < buttons.size(); i++) {
                    if (msg.x >= buttons[i].x && msg.x <= buttons[i].x + 180
                        && msg.y >= buttons[i].y && msg.y <= buttons[i].y + 50) {
                        hoverbutton = i;
                        break;
                    }
                }
                drawmenu(hoverbutton);
            }
            else if (msg.message == WM_LBUTTONDOWN) {
                hoverbutton = -1;
                for (int i = 0; i < buttons.size(); i++) {
                    if (msg.x >= buttons[i].x && msg.x <= buttons[i].x + 180
                        && msg.y >= buttons[i].y && msg.y <= buttons[i].y + 50) {
                        hoverbutton = i;
                        return hoverbutton;
                    }
                }
            }
        }
       
    }
}
void drawChessBoard() {
    drawbackground();
    int gap = 4; // æ ¼å­é—´éš™
    int shadowLayers = 8; // é˜´å½±æ¸å˜å±‚æ•°
    // 1. ç”»æ£‹ç›˜åº•è‰²
    setfillcolor(RGB(210, 210, 210));
    solidrectangle(BOARD_X, BOARD_Y,
        BOARD_X + GRIDSIZE * CELL_SIZE,
        BOARD_Y + GRIDSIZE * CELL_SIZE);
    // 2. ç”»äº¤ç‚¹é«˜å…‰ï¼ˆåªç”»å†…éƒ¨äº¤ç‚¹ï¼Œä¸”åŠå¾„ä¸å¤§äºgapï¼‰
    for (int i = 1; i < GRIDSIZE; i++) {
        for (int j = 1; j < GRIDSIZE; j++) {
            int cx = BOARD_X + j * CELL_SIZE;
            int cy = BOARD_Y + i * CELL_SIZE;
            for (int r = gap; r > 0; r--) {
                int bright = 255 - (gap - r) * 10;
                setfillcolor(RGB(bright, bright, bright));
                solidcircle(cx, cy, r);
            }
        }
    }
    // 3. ç”»æ ¼å­é˜´å½±ï¼ˆå³ä¸‹æ¸å˜ï¼‰
    for (int i = 0; i < GRIDSIZE; i++) {
        for (int j = 0; j < GRIDSIZE;j++) {
            int x1 = BOARD_X + j * CELL_SIZE + gap;
            int y1 = BOARD_Y + i * CELL_SIZE + gap;
            int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
            int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
            // å¤šå±‚é˜´å½±ï¼ˆå³ä¸‹åç§»ï¼‰
            for (int k = shadowLayers; k > 0; k--) {
                int alpha = 180 + k * 6; // ç”±æ·±åˆ°æµ…
                    int rx1 = x1 + k, ry1 = y1 + k;//é˜´å½±ä¸¾è¡Œå·¦ä¸Šè§’é¡¶ç‚¹
                    int rx2 = min(x2 + k, lowerboundary), ry2 = min(y2 + k, rightboundary);
                    //é˜´å½±çŸ©å½¢å³ä¸‹è§’é¡¶ç‚¹
                    if (rx1 >= lowerboundary || ry1 >= rightboundary) continue; // è·³è¿‡è¶…å‡ºæ£‹ç›˜çš„é˜´å½±
                    setfillcolor(RGB(alpha, alpha, alpha));
                    solidrectangle(rx1, ry1, rx2, ry2);
            }
        }
    }
    // 4. ç”»æ ¼å­æœ¬ä½“ï¼ˆç™½è‰²ï¼Œæœ€åç”»ï¼Œé®ä½é«˜å…‰å’Œé˜´å½±ï¼Œåªåœ¨ç¼éš™å¤„éœ²å‡ºï¼‰
    for (int i = 0; i < GRIDSIZE; ++i) {
        for (int j = 0; j < GRIDSIZE; ++j) {
            int x1 = BOARD_X + j * CELL_SIZE + gap;
            int y1 = BOARD_Y + i * CELL_SIZE + gap;
            int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
            int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
            setfillcolor(WHITE);
            solidrectangle(x1, y1, x2, y2);
        }
    }
    //è¦†ç›–åˆæ³•è·¯å¾„é«˜äº®
    for (int k = 0; k < legalmove.size(); k++) {
        int i = legalmove[k][0], j = legalmove[k][1];
        //// ä¸é«˜äº®é€‰ä¸­æ£‹å­æœ¬èº«
        //if (i == hoverr && j == hoverc) continue;
        int x1 = BOARD_X + j * CELL_SIZE + gap;
        int y1 = BOARD_Y + i * CELL_SIZE + gap;
        int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
        int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
        // ç”»å¤šå±‚å³ä¸‹åç§»æ¸å˜é˜´å½±
        int shadowLayers = 8;
        for (int k = shadowLayers; k > 0; k--) {
            setfillcolor(RGB(255, 255, 100 + k * 15)); // æ¸å˜é»„
            solidrectangle(x1 + k, y1 + k, x2 + k, y2 + k);
        }
        // æœ€ä¸Šå±‚é«˜äº®
        setfillcolor(RGB(220, 180, 40));
        solidrectangle(x1, y1, x2, y2);
    }
    for (int k = 0; k < legalarrow.size(); ++k) {
        int i = legalarrow[k][0], j = legalarrow[k][1];
        // é€‰ä¸­æ£‹å­æœ¬èº«ä¿æŒé»„è‰²
        if (i == destx && j == desty) {
            int x1 = BOARD_X + j * CELL_SIZE + gap;
            int y1 = BOARD_Y + i * CELL_SIZE + gap;
            int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
            int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
            int shadowLayers = 8;
            for (int k = shadowLayers; k > 0; k--) {
                setfillcolor(RGB(255, 255, 100 + k * 15)); // æ¸å˜é»„è‰²
                solidrectangle(x1 + k, y1 + k, x2 + k, y2 + k);
            }
            setfillcolor(RGB(220, 180, 40));
            solidrectangle(x1, y1, x2, y2);
            continue;

        }
        int x1 = BOARD_X + j * CELL_SIZE + gap;
        int y1 = BOARD_Y + i * CELL_SIZE + gap;
        int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
        int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
        int shadowLayers = 8;
        for (int k = shadowLayers; k > 0; k--) {
            setfillcolor(RGB(255, 80 + k * 10, 80 + k * 15)); // æ¸å˜çº¢
            solidrectangle(x1 + k, y1 + k, x2 + k, y2 + k);
        }
        setfillcolor(RGB(200, 40, 40));
        solidrectangle(x1, y1, x2, y2);
    }
    // ç»˜åˆ¶ä¸Šæ–¹å’Œå·¦ä¾§çš„æ•°å­—åæ ‡ï¼ˆ0-7ï¼‰
    settextstyle(20, 0, _T("åæ–‡è¡Œæ¥·")); // å°å­—ä½“
    settextcolor(BLACK);

    // ä¸Šæ–¹åˆ—åæ ‡
    for (int j = 0; j < GRIDSIZE; ++j) {
        int x = BOARD_X + j * CELL_SIZE + CELL_SIZE / 2 - 5; // å±…ä¸­å¾®è°ƒ
        int y = BOARD_Y - 22; // æ¯”æ£‹ç›˜ä¸Šè¾¹ç•Œç•¥é«˜ï¼Œé¿å…å’Œæç¤ºæ å†²çª
        wchar_t buf[2];
        swprintf(buf, 2, L"%d", j);
        outtextxy(x, y, buf);
    }

    // å·¦ä¾§è¡Œåæ ‡
    for (int i = 0; i < GRIDSIZE; ++i) {
        int x = BOARD_X - 18; // æ¯”æ£‹ç›˜å·¦è¾¹ç•Œç•¥å·¦
        int y = BOARD_Y + i * CELL_SIZE + CELL_SIZE / 2 - 8; // å±…ä¸­å¾®è°ƒ
        wchar_t buf[2];
        swprintf(buf, 2, L"%d", i);
        outtextxy(x, y, buf);
    }
}// ç”»æ£‹å­å’Œéšœç¢
void drawPieces() {
    for (int i = 0; i < GRIDSIZE; ++i) {
        for (int j = 0; j < GRIDSIZE; ++j) {
            int cx = BOARD_X + j * CELL_SIZE + CELL_SIZE / 2;
            int cy = BOARD_Y + i * CELL_SIZE + CELL_SIZE / 2;
            int shadowradius = CELL_SIZE / 2 - 6;
            int pieceradius = CELL_SIZE / 2 - 10;
            if (gridInfo[i][j] == grid_black) {
                bool isHover = (i == hoverr && j == hoverc && 
                    gridInfo[i][j] == currentcolor);
                // ç”»å¤šå±‚åŒå¿ƒåœ†æ¨¡æ‹Ÿæ·¡æ·¡çš„æ¸å˜é˜´å½±
                // ç”»é˜´å½±ï¼šæ‚¬åœç»¿è‰²æ¸å˜ï¼Œå¦åˆ™ç°è‰²æ¸å˜
                for (int r = shadowradius; r > shadowradius - 8; --r) {
                    if (isHover) {
                        int g = 255;
                        int base = 180 + (shadowradius - r) * 5;
                        setfillcolor(RGB(base, g, base)); // äº®ç»¿è‰²æ¸å˜
                    }
                    else {
                        int gray = 200 + (shadowradius - r) * 4;
                        setfillcolor(RGB(gray, gray, gray));
                    }
                    solidcircle(cx, cy, r);
                }
                setfillcolor(BLACK);
                solidcircle(cx, cy, pieceradius);
            }
            else if (gridInfo[i][j] == grid_white) {
                // é˜´å½±å‚æ•°
                bool ishover = (i == hoverr && j == hoverc &&
                    gridInfo[i][j] == currentcolor);
                // ç”»å¤šå±‚åŒå¿ƒåœ†æ¨¡æ‹Ÿæ·¡æ·¡çš„æ¸å˜é˜´å½±
                // ç”»é˜´å½±ï¼šæ‚¬åœç»¿è‰²æ¸å˜ï¼Œå¦åˆ™ç°è‰²æ¸å˜
                for (int r = shadowradius; r > shadowradius - 8; --r) {
                    if (ishover) {
                        int g = 255;
                        int base = 180 + (shadowradius - r) * 5;
                        setfillcolor(RGB(base, g, base)); // äº®ç»¿è‰²æ¸å˜
                    }
                    else {
                        int gray = 200 + (shadowradius - r) * 4;
                        setfillcolor(RGB(gray, gray, gray));
                    }
                    solidcircle(cx, cy, r);
                }
                    setfillcolor(WHITE);
                    setlinecolor(BLACK);
                    circle(cx, cy, pieceradius);//ç™½æ£‹é»‘è¾¹æ¡†
                    fillcircle(cx, cy, pieceradius);
            }
            else if (gridInfo[i][j] == obstacle) {
                for (int r = shadowradius; r > shadowradius - 8; --r) {
                    int gray = 200 + (shadowradius - r) * 4;
                    setfillcolor(RGB(gray, gray, gray));
                    solidcircle(cx, cy, r);
                }
                setfillcolor(BLUE);
                fillcircle(cx, cy, pieceradius);
                setlinecolor(BLACK);
                circle(cx, cy, pieceradius);//éšœç¢é»‘è‰²è¾¹æ¡†
            }
        }
    }
}
bool inMap(int x, int y) {
    if (x < 0 || x >= GRIDSIZE || y < 0 || y >= GRIDSIZE) {
        return false;
    }
    return true;
}
bool isPathClear(int x0, int y0, int x1, int y1) {
    int dx = x1 - x0, dy = y1 - y0;//èµ·ç‚¹åˆ°ç»ˆç‚¹çš„ä½ç½®å¢é‡
    int stepx=0;
    if (dx == 0)stepx = 0;
    else {
        if (dx > 0)stepx = 1;
        else stepx = -1;
    }
    int stepy = 0;
    if (dy == 0)stepy = 0;
    else {
        if (dy > 0)stepy = 1;
        else stepy = -1;
    }
    //èµ·ç‚¹åˆ°ç»ˆç‚¹çš„å•ä½æ­¥é•¿
    if (dx != 0 && dy != 0 && abs(dx) != abs(dy)) return false; // ä¸æ˜¯ç›´çº¿æˆ–æ–œçº¿
    int steps = max(abs(dx), abs(dy));//èµ·ç‚¹åˆ°ç»ˆç‚¹èµ°çš„æœ€å¤šæ­¥æ•°
    for (int i = 1; i < steps; i++ ) {
        int nx = x0 + stepx * i;
        int ny = y0 + stepy * i;
        if (!inMap(nx, ny) || gridInfo[nx][ny] != 0) return false;
    }
    return true;
}
bool legal(int x0, int y0, int x1, int y1, int x2, int y2, int color) {
    if (!inMap(x0, y0) || !inMap(x1, y1) || !inMap(x2, y2))return false;
    if (gridInfo[x1][y1] != 0)return false;
    if (gridInfo[x0][y0] != color)return false;
    if (gridInfo[x2][y2] != 0 && !(x2 == x0 && y2 == y0))return false;
    int temp = gridInfo[x0][y0];
    gridInfo[x0][y0] = 0;
    bool path = isPathClear(x0, y0, x1, y1) && isPathClear(x1, y1, x2, y2);
    gridInfo[x0][y0] = temp;
    return path;
}
bool check_fail (int color) {
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == color) {
                for (int i = 0; i < GRIDSIZE; i++) {
                    for (int step = 1; step < GRIDSIZE; step++) {
                        int nx = x + dx[i] * step;
                        int ny = y + dy[i] * step;
                        if (!inMap(nx, ny))break;
                        else if (gridInfo[nx][ny] != 0)break;
                        else {
                            for (int adir = 0; adir < 8; adir++) {
                                for (int astep = 1; astep < GRIDSIZE; astep++) {
                                    int ax = nx + dx[adir] * astep;
                                    int ay = ny + dy[adir] * astep;
                                    if (!inMap(ax, ay)) break;
                                    else if (ax == nx && ay == ny)continue;
                                    else if (gridInfo[ax][ay] != 0 && (!(ax == x && ay == y)))break;//è¿™é‡Œå°„ç®­ä¹Ÿè¦å…è®¸å›åˆ°åŸä½ç½®ï¼ï¼ï¼
                                    printf("check: %d %d -> %d %d -> %d %d, gridInfo[nx][ny]=%d, gridInfo[ax][ay]=%d\n", x, y, nx, ny, ax, ay, gridInfo[nx][ny], gridInfo[ax][ay]);
                                    if (legal(x, y, nx, ny, ax, ay, color)) {
                                        printf("åˆæ³•èµ°æ³•: %d %d -> %d %d -> %d %d\n", x, y, nx, ny, ax, ay);
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (color == 1) {
        MessageBox(GetHWnd(), _T("ç™½æ£‹èƒœåˆ©ï¼"), _T("æ¸¸æˆç»“æŸ"), MB_OK | MB_ICONINFORMATION);
    }
    else {
        MessageBox(GetHWnd(), _T("é»‘æ£‹èƒœåˆ©ï¼"), _T("æ¸¸æˆç»“æŸ"), MB_OK | MB_ICONINFORMATION);
    }
    return true;
}
bool isfail(int color) {
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == color) {
                for (int i = 0; i < GRIDSIZE; i++) {
                    for (int step = 1; step < GRIDSIZE; step++) {
                        int nx = x + dx[i] * step;
                        int ny = y + dy[i] * step;
                        if (!inMap(nx, ny))break;
                        else if (gridInfo[nx][ny] != 0)break;
                        else {
                            for (int adir = 0; adir < 8; adir++) {
                                for (int astep = 1; astep < GRIDSIZE; astep++) {
                                    int ax = nx + dx[adir] * astep;
                                    int ay = ny + dy[adir] * astep;
                                    if (!inMap(ax, ay)) break;
                                    else if (ax == nx && ay == ny)continue;
                                    else if (gridInfo[ax][ay] != 0 && (!(ax == x && ay == y)))break;//è¿™é‡Œå°„ç®­ä¹Ÿè¦å…è®¸å›åˆ°åŸä½ç½®ï¼ï¼
                                    if (legal(x, y, nx, ny, ax, ay, color)) {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return true;
}
bool ProcStep(int x0, int y0, int x1, int y1, int x2, int y2,
    int color, bool check_only)
{
    if (!legal(x0, y0, x1, y1, x2, y2, color))return false;
    if (!check_only)
    {
        gridInfo[x0][y0] = 0;
        gridInfo[x1][y1] = color;
        gridInfo[x2][y2] = obstacle;
    }
    return true;
}
void saveGame(const string& filename) {
    ofstream fout(filename, ios::binary); // æ‰“å¼€æ–‡ä»¶ï¼Œå‡†å¤‡å†™å…¥
    if (!fout) {
        MessageBox(GetHWnd(), _T("æ–‡ä»¶ä¿å­˜å¤±è´¥ï¼"), _T("é”™è¯¯"), MB_OK | MB_ICONERROR);
        return;
    }
    fout.write((char*)gridInfo, sizeof(gridInfo)); // å†™å…¥æ£‹ç›˜
    fout.write((char*)&currentcolor, sizeof(currentcolor)); // å†™å…¥å½“å‰é¢œè‰²
    fout.write((char*)&mycolor, sizeof(mycolor));  //å†™å…¥ç©å®¶é¢œè‰²
    fout.close(); // å…³é—­æ–‡ä»¶
    MessageBox(GetHWnd(), _T("æ–‡ä»¶å·²ä¿å­˜ï¼"), _T("æç¤º"), MB_OK | MB_ICONINFORMATION);// å†™å…¥ç©å®¶é¢œè‰²
}
void loadGame(const string& filename) {
    ifstream fin(filename, ios::binary); // æ‰“å¼€æ–‡ä»¶ï¼Œå‡†å¤‡è¯»å–
    if (!fin) {
        MessageBox(GetHWnd(), _T("æ–‡ä»¶è¯»å–å¤±è´¥ï¼"), _T("é”™è¯¯"), MB_OK | MB_ICONERROR);
        return;
    }
    fin.read((char*)gridInfo, sizeof(gridInfo)); // è¯»å›æ£‹ç›˜
    fin.read((char*)&currentcolor, sizeof(currentcolor)); // è¯»å›å½“å‰é¢œè‰²
    fin.read((char*)&mycolor, sizeof(mycolor));   
    // è¯»å›ç©å®¶é¢œè‰²
    fin.close(); // å…³é—­æ–‡ä»¶
    MessageBox(GetHWnd(), _T("æ–‡ä»¶å·²è¯»å–ï¼"), _T("æç¤º"), MB_OK | MB_ICONINFORMATION);
}
void humanMove() {
    int x0=0, y0=0, x1=0, y1=0, x2=0, y2=0;
    legalmove.clear();
    legalarrow.clear();
    //é€‰æ£‹å­
    while (1) {
        ExMessage msg;
        int f = 0;
        // é€‰æ£‹å­å‰
        settextstyle(32, 0, _T("å¾®è½¯é›…é»‘"));
        settextcolor(BLUE); // æ·±è“è‰²
        outtextxy(400, 0, L"è¯·ç‚¹å‡»æ£‹å­");
        while (peekmessage(&msg, EX_MOUSE)) {
            if (msg.message == WM_LBUTTONDOWN && (msg.x >= 440) && (msg.x <= 560) && (msg.y >= 630) && (msg.y <= 670)) {
                saveGame("amazons.sav");
            }
            if (msg.message == WM_LBUTTONDOWN && msg.x>=300&&msg.x<=420
                &&msg.y>=630&&msg.y<=670) {
                closegraph();
                exit(0);
            }
            if (msg.message == WM_MOUSEMOVE) {
                int row = (msg.y - BOARD_Y) / CELL_SIZE;
                int col = (msg.x - BOARD_X) / CELL_SIZE;
                if (inMap(row, col)&&gridInfo[row][col]==currentcolor) {
                    hoverr = row;
                    hoverc = col; 
                    cleardevice();
                    drawChessBoard();
                    drawPieces();
                    drawstatusbar(true);//æ£‹å­å°šæœªé€‰å®šï¼Œå…è®¸å­˜ç›˜
                }
                //æ¯æ¬¡ç»è¿‡åˆæ³•æ£‹å­ï¼Œæ›´æ–°hoverrå’Œhoverc,è°ƒç”¨drawboardï¼Œåˆ·æ–°æ£‹ç›˜
                //è¿™é‡Œå®ç°äººç±»é¼ æ ‡æ‚¬åœçš„ä½ç½®æ£‹å­ç»¿è‰²é«˜äº®
            }
            // æ–°å¢ï¼šSé”®å­˜ç›˜ï¼ŒRé”®è¯»ç›˜ï¼ŒESCç»“æŸæ¸¸æˆ
              // å­˜ç›˜ï¼šæŒ‰ä¸‹Sé”®
           /* if (msg.message == WM_LBUTTONDOWN && (msg.x>=440)&&(msg.x<=560)&&(msg.y>=630)&&(msg.y<=670)) {
                saveGame("amazons.sav");
                MessageBox(GetHWnd(), _T("æ¸¸æˆå·²ä¿å­˜ï¼"), _T("æç¤º"), MB_OK);
                
            }*/
            //// ä¸­é€”è¯»ç›˜ï¼šæŒ‰ä¸‹Ré”®
            //if (msg.message == WM_KEYDOWN && (msg.vkcode == 'R' || msg.vkcode == 'r')) {
            //    loadGame("amazons.sav");
            //    cleardevice();
            //    drawChessBoard();
            //    drawPieces();
            //}
        /*    if (msg.message == WM_KEYDOWN && msg.vkcode == VK_ESCAPE) {
                closegraph();
                exit(0);
            }*/
            if (msg.message == WM_LBUTTONDOWN) {
                int row = (msg.y - BOARD_Y) / CELL_SIZE;
                int col = (msg.x - BOARD_X) / CELL_SIZE;//è½¬æ¢åæ ‡
                printf("ç‚¹å‡»: x=%d y=%d row=%d col=%d inMap=%d gridInfo=%d currentcolor=%d\n",
                msg.x, msg.y, row, col, inMap(row, col), inMap(row, col) ? gridInfo[row][col] : -99, currentcolor);
                //è°ƒè¯•è¾“å‡ºç‚¹å‡»ä½ç½®ï¼Œå¦‚æœç‚¹å‡»ä½ç½®åœ¨æ£‹ç›˜å¤–éƒ¨é‚£ä¹ˆè¾“å‡º-99
                if (inMap(row, col) && gridInfo[row][col] == currentcolor) {
                    printf("é€‰ä¸­æ£‹å­: row=%d col=%d\n", row, col);
                    x0 = row;
                    y0 = col;
                    f = 1;
                    break;
                }
            }
        }
        if (f) break;
    }
    for (int dir = 0; dir < 8; dir++) {
        for (int step = 1; step < GRIDSIZE; step++) {
            int nx = x0 + dx[dir] * step;
            int ny = y0 + dy[dir] * step;
            if (!inMap(nx, ny) || gridInfo[nx][ny] != 0) break;
            legalmove.push_back({ nx, ny });
        }
    }
    cleardevice();
    drawChessBoard();
    drawPieces();
    drawstatusbar(false);//æ­¤æ—¶å·²ç»ä¸å…è®¸å­˜ç›˜
    // é€‰ç›®æ ‡æ ¼
    while (true) {
        ExMessage msg;
        int f = 0;
        // é€‰ç›®æ ‡æ ¼å‰
        settextstyle(32, 0, _T("å¾®è½¯é›…é»‘"));
        settextcolor(BLUE);
        outtextxy(400, 0, L"è¯·é€‰æ‹©ç›®æ ‡ä½ç½®");
        while (peekmessage(&msg, EX_MOUSE)) {
           /* if (msg.message == WM_RBUTTONDOWN) {
                saveGame("amazons.sav");
                MessageBox(GetHWnd(), _T("æ¸¸æˆå·²ä¿å­˜ï¼"), _T("æç¤º"), MB_OK);
            }*/
            //if (msg.message == WM_KEYDOWN && msg.vkcode == VK_ESCAPE) {
            //    closegraph();
            //    exit(0);
            //}
            if (msg.message == WM_LBUTTONDOWN && msg.x >= 300 
                && msg.x <= 420 && msg.y >= 630 && msg.y <= 670) {
                closegraph();
                exit(0);
            }
            if (msg.message == WM_LBUTTONDOWN) {
                int row = (msg.y - BOARD_Y) / CELL_SIZE;
                int col = (msg.x - BOARD_X) / CELL_SIZE;
                if (inMap(row, col) && gridInfo[row][col] == 0&&isPathClear(x0,y0,row,col)) {
                    x1 = row; 
                    y1 = col;
                    destx = row;
                    desty = col;
                    f = 1;
                    cout << "é€‰ä¸­ä½ç½®ï¼šrow=" << row << " col=" << col << endl;
                    break;
                }
            }
        }
        if (f)break;
    }
    for (int i = 0; i < 8; i++) {
        for (int step = 0; step < 8; step++) {
            int ax = x1 + dx[i] * step;
            int ay = y1 + dy[i] * step;
            if (!inMap(ax, ay) || (gridInfo[ax][ay] != 0) && (ax != x0 && ay != y0))break;
            if (legal(x0, y0, x1, y1, ax, ay, currentcolor)) {
                legalarrow.push_back({ ax,ay });
            }
        }
    }
    legalmove.clear();
    cleardevice();
    drawChessBoard();
    drawPieces();
    drawstatusbar(false);
    //é€‰å°„ç®­
    while (true) {
        // é€‰å°„ç®­å‰
        settextstyle(32, 0, _T("å¾®è½¯é›…é»‘"));
        settextcolor(BLUE);
        outtextxy(400, 0, L"è¯·é€‰æ‹©å°„ç®­ä½ç½®");
        ExMessage msg;
        int f = 0;
        while (peekmessage(&msg, EX_MOUSE)) {
            // æ–°å¢ï¼šå³é”®å­˜ç›˜ï¼ŒESCç»“æŸæ¸¸æˆ
           /* if (msg.message == WM_RBUTTONDOWN) {
                saveGame("amazons.sav");
                MessageBox(GetHWnd(), _T("æ¸¸æˆå·²ä¿å­˜ï¼"), _T("æç¤º"), MB_OK);
            }
            if (msg.message == WM_KEYDOWN && msg.vkcode == VK_ESCAPE) {
                closegraph();
                exit(0);
            }*/
            if (msg.message == WM_LBUTTONDOWN && msg.x >= 300 && 
                msg.x <= 420 && msg.y >= 630 && msg.y <= 670) {
                closegraph();
                exit(0);
            }
            if (msg.message == WM_LBUTTONDOWN) {
                int row = (msg.y - BOARD_Y) / CELL_SIZE;
                int col = (msg.x - BOARD_X) / CELL_SIZE;
                //äººç±»çš„åˆæ³•å°„ç®­åˆ¤åˆ«éœ€è¦æ’é™¤æ‰ç›®æ ‡ç‚¹
                if (inMap(row, col) && (gridInfo[row][col] == 0||(row==x0&&col==y0) )
                    && legal(x0, y0, x1, y1, row, col, currentcolor)&&!(row==x1&&col==y1)) {
                    x2 = row;
                    y2 = col;
                    f = 1;
                    cout << "é€‰ä¸­å°„ç®­ï¼š row=" << row << " col=" << col << endl;
                    break;
                }
            }
        }
        if (f&&ProcStep(x0, y0, x1, y1, x2, y2, currentcolor, false)) {
            break;
        }
    }
    legalarrow.clear();
    cleardevice();
    drawChessBoard();
    drawPieces();
    return;
}
int fastmobility(int color) {
    int score = 0;
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == color) {
                for (int dir = 0; dir < 8; dir++) {
                    for (int step = 1; step <= 4; step++) {
                        int nx = x + dx[dir] * step, ny = y + dy[dir] * step;
                        if (!inMap(nx, ny) || gridInfo[nx][ny] != 0) break;
                        score += 5;
                    }
                }
            }
        }
    }
    return score;
}
int blockscore(int color) {
    int c = 0;
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == obstacle) {
                bool block = false;
                for (int dir = 0; dir < 8; dir++) {
                    int nx = x + dx[dir], ny = y + dy[dir];
                    if (inMap(nx, ny) && gridInfo[nx][ny] == -color) {
                        block = true;
                        break;
                    }
                }
                if (block) {
                    c += 10;

                }
            }
        }
    }
    return c;
}
int evaluate() {
    int score = 0;
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == currentcolor) {
                for (int dir = 0; dir < 8; dir++) {
                    for (int step = 1; step <= 4; step++) {
                        int nx = x + dx[dir] * step, ny = y + dy[dir] * step;
                        if (!inMap(nx, ny) || gridInfo[nx][ny] != 0) break;
                        score += 5;
                    }//æ¯ä¸ªæ–¹å‘æ¯æ­¥+5
                }
            }
            else if (gridInfo[x][y] == -currentcolor) {
                for (int dir = 0; dir < 8; dir++) {
                    for (int step = 1; step <= 4; step++) {
                        int nx = x + dx[dir] * step, ny = y + dy[dir] * step;
                        if (!inMap(nx, ny) || gridInfo[nx][ny] != 0) break;
                        score -= 5;
                    }
                }
            }
            else if (gridInfo[x][y] == obstacle) {
                bool block = false;
                for (int dir = 0; dir < 8; dir++) {
                    int nx = x + dx[dir], ny = y + dy[dir];
                    if (inMap(nx, ny) && gridInfo[nx][ny] == -currentcolor) {
                        block = true;
                        break;
                    }
                }
                if (block) {
                    score += 10;
                }
            }
        }
    }
    return score;
}
const int MAX_SEARCH_TIME = 900; // ms
bool timeOut = false;
int minimax(int color, int alpha, int beta, int depth, int maxdepth) {
    if (timeOut) return evaluate();
    auto now = steady_clock::now();
    if (duration_cast<milliseconds>(now - startTime).count() >= MAX_SEARCH_TIME) {
        timeOut = true;
        return evaluate(); // æˆ–ç”¨ä½ çš„è¯„ä¼°å‡½æ•°
    }
    if (isfail(color))return -1e9;//è¾“çš„å­èŠ‚ç‚¹è¿”å›æå°å€¼
    if (isfail(-color))return 1e9;//èµ¢çš„å­èŠ‚ç‚¹è¿”å›æœ€å¤§å€¼
    if (depth == maxdepth || timeOut) return evaluate();
    struct Move { int x0, y0, x1, y1, x2, y2; };
    vector<Move>moves;//æšä¸¾æ‰€æœ‰èµ°æ³•å­˜å…¥movesç»“æ„ä½“æ•°ç»„
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == color) {
                for (int dir = 0; dir < 8; dir++) {
                    for (int step = 1; step <= 4; step++) {
                        int nx = x + dx[dir] * step;
                        int ny = y + dy[dir] * step;
                        if (!inMap(nx, ny)) break;
                        if (gridInfo[nx][ny] != 0) break;
                        // å°„ç®­
                        for (int adir = 0; adir < 8; adir++) {
                            for (int astep = 1; astep <= 4; astep++) {
                                int ax = nx + dx[adir] * astep;
                                int ay = ny + dy[adir] * astep;
                                if (!inMap(ax, ay)) break;
                                else if (gridInfo[ax][ay] != 0 && !(ax == x && ay == y)) break;
                                // åˆ¤æ–­å®Œæ•´åˆæ³•æ€§
                                // è¿™é‡Œç”¨å½“å‰colorï¼Œä¸å½±å“ä¸»æµç¨‹
                                if (legal(x, y, nx, ny, ax, ay, color)) {
                                    moves.push_back({ x,y,nx,ny,ax,ay });
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (color == currentcolor) {
        for (size_t i = 0; i < moves.size() /*&& i < static_cast<size_t>(n)*/; i++) {
            int backup[GRIDSIZE][GRIDSIZE];
            memcpy(backup, gridInfo, sizeof(gridInfo));
            ProcStep(moves[i].x0, moves[i].y0, moves[i].x1, moves[i].y1, moves[i].x2,
                moves[i].y2, color, false);
            /*printf("AIå€™é€‰èµ°æ³•: %d %d -> %d %d -> %d %d\n", x, y, nx, ny, ax, ay);*/
            int score = minimax(-color, alpha, beta, depth + 1, maxdepth);
            /* printf("minimaxåˆ†æ•°: %d\n", score);*/
            alpha = max(score, alpha);
            memcpy(gridInfo, backup, sizeof(backup));
            if (alpha >= beta)break;
            if (timeOut)break;

        }
        return alpha;
    }
    else {
        for (size_t i = 0; i < moves.size() /*&& i < static_cast<size_t>(n)*/; i++) {
            int backup[GRIDSIZE][GRIDSIZE];
            memcpy(backup, gridInfo, sizeof(gridInfo));
            ProcStep(moves[i].x0, moves[i].y0, moves[i].x1, moves[i].y1, moves[i].x2,
                moves[i].y2, color, false);
            /*printf("AIå€™é€‰èµ°æ³•: %d %d -> %d %d -> %d %d\n", x, y, nx, ny, ax, ay);*/
            int score = minimax(-color, alpha, beta, depth + 1, maxdepth);
            /* printf("minimaxåˆ†æ•°: %d\n", score);*/
            beta = min(score, beta);
            memcpy(gridInfo, backup, sizeof(backup));
            if (alpha >= beta)break;
            if (timeOut)break;
        }
        return beta;
    }
}
void aiMove() {
    struct Move { int x0, y0, x1, y1, x2, y2; };
    vector<Move>bestmoves;
    int bestscore = -1e9;
    int backup[GRIDSIZE][GRIDSIZE];
    vector<Move>moves;//æšä¸¾æ‰€æœ‰èµ°æ³•å­˜å…¥movesç»“æ„ä½“æ•°ç»„
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == currentcolor) {
                for (int dir = 0; dir < 8; dir++) {
                    for (int step = 1; step <= 4; step++) {
                        int nx = x + dx[dir] * step;
                        int ny = y + dy[dir] * step;
                        if (!inMap(nx, ny)) break;
                        if (gridInfo[nx][ny] != 0) break;
                        // å°„ç®­
                        for (int adir = 0; adir < 8; adir++) {
                            for (int astep = 1; astep <= 4; astep++) {
                                int ax = nx + dx[adir] * astep;
                                int ay = ny + dy[adir] * astep;
                                if (!inMap(ax, ay)) break;
                                else if (gridInfo[ax][ay] != 0 && !(ax == x && ay == y)) break;
                                // åˆ¤æ–­å®Œæ•´åˆæ³•æ€§
                                // è¿™é‡Œç”¨å½“å‰colorï¼Œä¸å½±å“ä¸»æµç¨‹
                                if (legal(x, y, nx, ny, ax, ay, currentcolor)) {
                                    moves.push_back({ x,y,nx,ny,ax,ay });
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // ç”¨mobilityå·®æ’åº
    sort(moves.begin(), moves.end(), [&](const Move& a, const Move& b) {
        int backup[GRIDSIZE][GRIDSIZE];
        memcpy(backup, gridInfo, sizeof(gridInfo));
        ProcStep(a.x0, a.y0, a.x1, a.y1, a.x2, a.y2, currentcolor, false);
        int scoreA = fastmobility(currentcolor) - fastmobility(-currentcolor) + 5 * blockscore(currentcolor);
        memcpy(gridInfo, backup, sizeof(gridInfo));
        ProcStep(b.x0, b.y0, b.x1, b.y1, b.x2, b.y2, currentcolor, false);
        int scoreB = fastmobility(currentcolor) - fastmobility(-currentcolor) + 5 * blockscore(currentcolor);
        memcpy(gridInfo, backup, sizeof(gridInfo));
        return scoreA > scoreB;
        });
    Move lastBestMove = { -1, -1, -1, -1, -1, -1 };
    for (int depth = 1; depth <= 5; depth++) {
        if (timeOut)break;
        bestscore = -1e9;
        bestmoves.clear();
        for (size_t i = 0; i < moves.size(); i++) {
            memcpy(backup, gridInfo, sizeof(gridInfo));
            ProcStep(moves[i].x0, moves[i].y0, moves[i].x1, moves[i].y1, moves[i].x2, moves[i].y2, currentcolor, false);
            int score = minimax(-currentcolor, -1e9, 1e9, 1, depth);
            memcpy(gridInfo, backup, sizeof(gridInfo));
            if (score > bestscore) {
                bestscore = score;
                bestmoves.clear();
                bestmoves.push_back({ moves[i].x0, moves[i].y0, moves[i].x1, moves[i].y1, moves[i].x2, moves[i].y2
                    });
            }
            else if (score == bestscore) {
                bestmoves.push_back({ moves[i].x0, moves[i].y0, moves[i].x1, moves[i].y1, moves[i].x2, moves[i].y2 });
            }
        }
        if (!timeOut && !bestmoves.empty()) {
            lastBestMove = bestmoves[rand() % bestmoves.size()];
        }
    }
    // å…œåº•ï¼šå¦‚æœlastBestMoveæœªè¢«æ›´æ–°ä¸”moveséç©ºï¼Œéšæœºè¾“å‡ºä¸€ä¸ªåˆæ³•èµ°æ³•
    if (lastBestMove.x0 == -1 && !moves.empty()) {
        lastBestMove = moves[rand() % moves.size()];
    }
    cout << "AIèµ°æ­¥: " << lastBestMove.y0 << " " << lastBestMove.x0 << " "
        << lastBestMove.y1 << " " << lastBestMove.x1 << " "
        << lastBestMove.y2 << " " << lastBestMove.x2 << endl;
    if (lastBestMove.x0 != -1) {
        ProcStep(lastBestMove.x0, lastBestMove.y0, lastBestMove.x1, lastBestMove.y1, lastBestMove.x2, lastBestMove.y2, currentcolor, false);
    }
    cleardevice();
    drawChessBoard();
    drawPieces();
    drawstatusbar(true); // AIèµ°æ­¥å®Œæˆï¼Œç”»å‡ºä¸¤ä¸ªæŒ‰é’®
    settextstyle(32, 0, _T("å¾®è½¯é›…é»‘"));
    settextcolor(BLUE);
    wstringstream wss;
    wss << L"AIèµ°æ­¥: " << lastBestMove.x0 << L" " << lastBestMove.y0 << L" "
        << lastBestMove.x1 << L" " << lastBestMove.y1 << L" "
        << lastBestMove.x2 << L" " << lastBestMove.y2;
    outtextxy(50, 0, wss.str().c_str());
}
void initBoard() {
    memset(gridInfo, 0, sizeof(gridInfo));
    gridInfo[0][(GRIDSIZE - 1) / 3] = gridInfo[(GRIDSIZE - 1) / 3][0]
        = gridInfo[GRIDSIZE - 1 - ((GRIDSIZE - 1) / 3)][0]
        = gridInfo[GRIDSIZE - 1][(GRIDSIZE - 1) / 3] = grid_black;
    gridInfo[0][GRIDSIZE - 1 - ((GRIDSIZE - 1) / 3)] = gridInfo[(GRIDSIZE - 1) / 3][GRIDSIZE - 1]
        = gridInfo[GRIDSIZE - 1 - ((GRIDSIZE - 1) / 3)][GRIDSIZE - 1]
        = gridInfo[GRIDSIZE - 1][GRIDSIZE - 1 - ((GRIDSIZE - 1) / 3)] = grid_white;
}
int main() {
    srand((unsigned)time(0)); // åªéœ€åœ¨mainé‡Œè°ƒç”¨ä¸€æ¬¡å³å¯
    initBoard(); 
    initgraph(600, 700); 
    cleardevice();
    setbkcolor(RGB(128, 128, 128));
    drawbackground();
    drawmenu(hoverbutton);
    while (1) {
        int x = selectmenu();
        if (x == 0) {
            PlaySound(_T("GameSelectionSound.wav"), NULL, SND_FILENAME | SND_ASYNC);
            cleardevice();
            drawbackground();

            // ç»˜åˆ¶é»‘æ£‹æŒ‰é’®
            setfillcolor(YELLOW);
            fillroundrect(150, 140, 450, 200, 30, 30);
            settextcolor(BLACK);
            settextstyle(36, 0, _T("å¾®è½¯é›…é»‘"));
            outtextxy(200, 155, L"âš« ç‚¹å‡»è¿™é‡Œæ‰§é»‘");
            // ç»˜åˆ¶ç™½æ£‹æŒ‰é’®
            setfillcolor(YELLOW);
            fillroundrect(150, 240, 450, 300, 30, 30);
            settextcolor(BLACK);
            settextstyle(36, 0, _T("å¾®è½¯é›…é»‘"));
            outtextxy(200, 255, L"âšª ç‚¹å‡»è¿™é‡Œæ‰§ç™½");
            while (1) {
                ExMessage msg;
                if (peekmessage(&msg, EM_MOUSE)) {
                    if (msg.message == WM_LBUTTONDOWN) {
                        PlaySound(_T("Game Selection Sound.wav"), NULL, SND_FILENAME | SND_ASYNC);
                        if (msg.x >= 150 && msg.x <= 450 && msg.y >= 140 && msg.y <= 200) {
                            mycolor = 1;
                            MessageBox(GetHWnd(), _T("ä½ é€‰æ‹©äº†é»‘æ£‹"), _T("æç¤º"), MB_OK);
                            currentcolor = mycolor;
                            cleardevice();
                            drawChessBoard();
                            drawPieces();
                            break;
                        }
                        if (msg.x >= 150 && msg.x <= 450 && msg.y >= 240 && msg.y <= 300) {
                            mycolor = -1;
                            MessageBox(GetHWnd(), _T("ä½ é€‰æ‹©äº†ç™½æ£‹"), _T("æç¤º"), MB_OK);
                            currentcolor = mycolor;
                            cleardevice();
                            drawChessBoard();
                            drawPieces();
                            drawstatusbar(true);
                            break;
                        }
                    }
                }
            }
            break;
        }
        else if (x== 1){
            loadGame("amazons.sav");
            cleardevice();
            drawChessBoard();
            drawPieces();
            break;
        }
        else if (x == 2) {
            closegraph();
            exit(0);
        }
    }
    while (true) {
            // ç©å®¶å›åˆ
            currentcolor = mycolor;
            if (check_fail(currentcolor))break;
            humanMove();
             // AIå›åˆ
            currentcolor = -1 * mycolor;
            if (check_fail(currentcolor))break;
            aiMove();
    }
    closegraph();
}
