#include<iostream>
#include<cmath>
#include<vector>
#include <cstdlib>
#include <fstream>
#include <ctime>
#include<sstream>
#include<string>
#include<graphics.h>
#include<conio.h>
using namespace std;
const int GRIDSIZE = 8;
int gridInfo[GRIDSIZE][GRIDSIZE];
const int grid_black = 1;
const int grid_white = -1;
const int obstacle = 2;
int currentcolor, rivalcolor;
int mycolor; // äººæœºæ¨¡å¼ä¸‹ï¼Œç©å®¶æ‰§å­é¢œè‰²
int dx[8] = { -1,-1,-1,0,0,1,1,1 };
int dy[8] = { -1,0,1,-1,1,-1,0,1 };
int hoverr = -1, hoverc = -1;//é¼ æ ‡æ‚¬åœçš„è¡Œä»¥åŠåˆ—
vector<vector<int>>legalmove;//æ‰€æœ‰åˆæ³•æ£‹å­è·¯å¾„
vector<vector<int>>legalarrow;//æ‰€æœ‰åˆæ³•å°„ç®­è·¯å¾„
int destx, desty = 0;//è®°å½•å½“å‰é€‰å®šçš„ç›®æ ‡æ£‹å­ä½ç½®
//updateï¼šå›¾å½¢ç•Œé¢é¼ æ ‡é€‰æ‹©èœå•
//å¾…å®Œæˆï¼šæ‚”æ£‹ï¼Œæå¤§æå°æœç´¢ï¼Œäººç±»ç©å®¶ä¸å…è®¸é€‰æ‹©æ­»æ‰çš„æ£‹å­ï¼Œä¸­é€”å­˜ç›˜è¯»ç›˜æŒ‰é’®
// æ£‹ç›˜å·¦ä¸Šè§’åæ ‡å’Œæ ¼å­å¤§å°
const int BOARD_X = 50, BOARD_Y = 50, CELL_SIZE = 60;//æ£‹ç›˜å·¦ä¸Šè§’ç‚¹çš„åæ ‡ï¼Œå•ä¸ªæ ¼å­è¾¹é•¿
const int lowerboundary = BOARD_X + GRIDSIZE * CELL_SIZE;//æ£‹ç›˜ä¸‹è¾¹ç•Œ
const int rightboundary = BOARD_Y + GRIDSIZE * CELL_SIZE;//æ£‹ç›˜å³è¾¹ç•Œ
int hoverbutton = -1;
vector<wstring> icons{ L"â–¶", L"ğŸ“‚", L"X" };
struct button {
    int x, y, w, h;//æŒ‰é’®å·¦ä¸Šè§’åæ ‡x,yï¼Œå®½wï¼Œé«˜h
    wstring text;//æŒ‰é’®çš„æ–‡å­—
};
vector<button>buttons{
    {180,140,180,50,L"æ–°å¼€å§‹"},
    {180,220,180,50,L"è¯»ç›˜"},{180,300,180,50,L"é€€å‡º"}
};
void drawmenu(int hoverbutton) {
    setbkcolor(RGB(128, 128, 128));
    wstring ws = L"ä¸»èœå•";
    settextstyle(30, 0, _T("å¾®è½¯é›…é»‘"));
    setbkmode(TRANSPARENT);
    settextcolor(BLUE);
    outtextxy(230,80,ws.c_str());
    for (int i = 0; i < buttons.size(); i++) {
            // æ‚¬åœé«˜äº®
            if (i == hoverbutton) {
                setfillcolor(RGB(220, 220, 100)); // é»„è‰²é«˜äº®
            }
            else {
                setfillcolor(RGB(210, 210, 210)); // æ™®é€šç°è‰²
            }
            roundrect(buttons[i].x, buttons[i].y, buttons[i].x + buttons[i].w, buttons[i].y + buttons[i].h,30,30);
            fillroundrect(buttons[i].x, buttons[i].y, buttons[i].x + buttons[i].w, buttons[i].y + buttons[i].h, 30, 30);
            settextstyle(30, 0, _T("å¾®è½¯é›…é»‘"));
            setbkmode(TRANSPARENT);
            settextcolor(BLACK);
            outtextxy(buttons[i].x+50, buttons[i].y+10, buttons[i].text.c_str());
            outtextxy(buttons[i].x+10, buttons[i].y+10, icons[i].c_str());
    }
}
void drawbackground() {
    for (int i =0; i <600; i += 2) {
        setfillcolor(RGB(80 + (600-i) / 10, 80 + (600-i) / 10, 80 + (600-i) / 10));
        solidrectangle(0, i, 600, i + 2);
    }
}
int selectmenu() {
    drawmenu(hoverbutton);
    while (1) {
        ExMessage msg;
        if (peekmessage(&msg, EX_MOUSE)) {
            if (msg.message == WM_MOUSEMOVE) {
                hoverbutton = -1;
                for (int i = 0; i < buttons.size(); i++) {
                    if (msg.x >= buttons[i].x && msg.x <= buttons[i].x + 180
                        && msg.y >= buttons[i].y && msg.y <= buttons[i].y + 50) {
                        hoverbutton = i;
                        break;
                    }
                }
                drawmenu(hoverbutton);
            }
            else if (msg.message == WM_LBUTTONDOWN) {
                hoverbutton = -1;
                for (int i = 0; i < buttons.size(); i++) {
                    if (msg.x >= buttons[i].x && msg.x <= buttons[i].x + 180
                        && msg.y >= buttons[i].y && msg.y <= buttons[i].y + 50) {
                        hoverbutton = i;
                        return hoverbutton;
                    }
                }
            }
        }
       
    }
}
void drawChessBoard() {
    int gap = 4; // æ ¼å­é—´éš™
    int shadowLayers = 8; // é˜´å½±æ¸å˜å±‚æ•°
    // 1. ç”»æ£‹ç›˜åº•è‰²
    setfillcolor(RGB(210, 210, 210));
    solidrectangle(BOARD_X, BOARD_Y,
        BOARD_X + GRIDSIZE * CELL_SIZE,
        BOARD_Y + GRIDSIZE * CELL_SIZE);
    // 2. ç”»äº¤ç‚¹é«˜å…‰ï¼ˆåªç”»å†…éƒ¨äº¤ç‚¹ï¼Œä¸”åŠå¾„ä¸å¤§äºgapï¼‰
    for (int i = 1; i < GRIDSIZE; i++) {
        for (int j = 1; j < GRIDSIZE; j++) {
            int cx = BOARD_X + j * CELL_SIZE;
            int cy = BOARD_Y + i * CELL_SIZE;
            for (int r = gap; r > 0; r--) {
                int bright = 255 - (gap - r) * 10;
                setfillcolor(RGB(bright, bright, bright));
                solidcircle(cx, cy, r);
            }
        }
    }
    // 3. ç”»æ ¼å­é˜´å½±ï¼ˆå³ä¸‹æ¸å˜ï¼‰
    for (int i = 0; i < GRIDSIZE; i++) {
        for (int j = 0; j < GRIDSIZE;j++) {
            int x1 = BOARD_X + j * CELL_SIZE + gap;
            int y1 = BOARD_Y + i * CELL_SIZE + gap;
            int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
            int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
            // å¤šå±‚é˜´å½±ï¼ˆå³ä¸‹åç§»ï¼‰
            for (int k = shadowLayers; k > 0; k--) {
                int alpha = 180 + k * 6; // ç”±æ·±åˆ°æµ…
                    int rx1 = x1 + k, ry1 = y1 + k;//é˜´å½±ä¸¾è¡Œå·¦ä¸Šè§’é¡¶ç‚¹
                    int rx2 = min(x2 + k, lowerboundary), ry2 = min(y2 + k, rightboundary);
                    //é˜´å½±çŸ©å½¢å³ä¸‹è§’é¡¶ç‚¹
                    if (rx1 >= lowerboundary || ry1 >= rightboundary) continue; // è·³è¿‡è¶…å‡ºæ£‹ç›˜çš„é˜´å½±
                    setfillcolor(RGB(alpha, alpha, alpha));
                    solidrectangle(rx1, ry1, rx2, ry2);
            }
        }
    }
    // 4. ç”»æ ¼å­æœ¬ä½“ï¼ˆç™½è‰²ï¼Œæœ€åç”»ï¼Œé®ä½é«˜å…‰å’Œé˜´å½±ï¼Œåªåœ¨ç¼éš™å¤„éœ²å‡ºï¼‰
    for (int i = 0; i < GRIDSIZE; ++i) {
        for (int j = 0; j < GRIDSIZE; ++j) {
            int x1 = BOARD_X + j * CELL_SIZE + gap;
            int y1 = BOARD_Y + i * CELL_SIZE + gap;
            int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
            int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
            setfillcolor(WHITE);
            solidrectangle(x1, y1, x2, y2);
        }
    }
    //è¦†ç›–åˆæ³•è·¯å¾„é«˜äº®
    for (int k = 0; k < legalmove.size(); k++) {
        int i = legalmove[k][0], j = legalmove[k][1];
        //// ä¸é«˜äº®é€‰ä¸­æ£‹å­æœ¬èº«
        //if (i == hoverr && j == hoverc) continue;
        int x1 = BOARD_X + j * CELL_SIZE + gap;
        int y1 = BOARD_Y + i * CELL_SIZE + gap;
        int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
        int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
        // ç”»å¤šå±‚å³ä¸‹åç§»æ¸å˜é˜´å½±
        int shadowLayers = 8;
        for (int k = shadowLayers; k > 0; k--) {
            setfillcolor(RGB(255, 255, 100 + k * 15)); // æ¸å˜é»„
            solidrectangle(x1 + k, y1 + k, x2 + k, y2 + k);
        }
        // æœ€ä¸Šå±‚é«˜äº®
        setfillcolor(RGB(220, 180, 40));
        solidrectangle(x1, y1, x2, y2);
    }
    for (int k = 0; k < legalarrow.size(); ++k) {
        int i = legalarrow[k][0], j = legalarrow[k][1];
        // é€‰ä¸­æ£‹å­æœ¬èº«ä¿æŒé»„è‰²
        if (i == destx && j == desty) {
            int x1 = BOARD_X + j * CELL_SIZE + gap;
            int y1 = BOARD_Y + i * CELL_SIZE + gap;
            int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
            int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
            int shadowLayers = 8;
            for (int k = shadowLayers; k > 0; k--) {
                setfillcolor(RGB(255, 255, 100 + k * 15)); // æ¸å˜é»„è‰²
                solidrectangle(x1 + k, y1 + k, x2 + k, y2 + k);
            }
            setfillcolor(RGB(220, 180, 40));
            solidrectangle(x1, y1, x2, y2);
            continue;

        }
        int x1 = BOARD_X + j * CELL_SIZE + gap;
        int y1 = BOARD_Y + i * CELL_SIZE + gap;
        int x2 = BOARD_X + (j + 1) * CELL_SIZE - gap;
        int y2 = BOARD_Y + (i + 1) * CELL_SIZE - gap;
        int shadowLayers = 8;
        for (int k = shadowLayers; k > 0; k--) {
            setfillcolor(RGB(255, 80 + k * 10, 80 + k * 15)); // æ¸å˜çº¢
            solidrectangle(x1 + k, y1 + k, x2 + k, y2 + k);
        }
        setfillcolor(RGB(200, 40, 40));
        solidrectangle(x1, y1, x2, y2);
    }
}// ç”»æ£‹å­å’Œéšœç¢
void drawPieces() {
    for (int i = 0; i < GRIDSIZE; ++i) {
        for (int j = 0; j < GRIDSIZE; ++j) {
            int cx = BOARD_X + j * CELL_SIZE + CELL_SIZE / 2;
            int cy = BOARD_Y + i * CELL_SIZE + CELL_SIZE / 2;
            int shadowradius = CELL_SIZE / 2 - 6;
            int pieceradius = CELL_SIZE / 2 - 10;
            if (gridInfo[i][j] == grid_black) {
                bool isHover = (i == hoverr && j == hoverc && 
                    gridInfo[i][j] == currentcolor);
                // ç”»å¤šå±‚åŒå¿ƒåœ†æ¨¡æ‹Ÿæ·¡æ·¡çš„æ¸å˜é˜´å½±
                // ç”»é˜´å½±ï¼šæ‚¬åœç»¿è‰²æ¸å˜ï¼Œå¦åˆ™ç°è‰²æ¸å˜
                for (int r = shadowradius; r > shadowradius - 8; --r) {
                    if (isHover) {
                        int g = 255;
                        int base = 180 + (shadowradius - r) * 5;
                        setfillcolor(RGB(base, g, base)); // äº®ç»¿è‰²æ¸å˜
                    }
                    else {
                        int gray = 200 + (shadowradius - r) * 4;
                        setfillcolor(RGB(gray, gray, gray));
                    }
                    solidcircle(cx, cy, r);
                }
                setfillcolor(BLACK);
                solidcircle(cx, cy, pieceradius);
            }
            else if (gridInfo[i][j] == grid_white) {
                // é˜´å½±å‚æ•°
                bool ishover = (i == hoverr && j == hoverc &&
                    gridInfo[i][j] == currentcolor);
                // ç”»å¤šå±‚åŒå¿ƒåœ†æ¨¡æ‹Ÿæ·¡æ·¡çš„æ¸å˜é˜´å½±
                // ç”»é˜´å½±ï¼šæ‚¬åœç»¿è‰²æ¸å˜ï¼Œå¦åˆ™ç°è‰²æ¸å˜
                for (int r = shadowradius; r > shadowradius - 8; --r) {
                    if (ishover) {
                        int g = 255;
                        int base = 180 + (shadowradius - r) * 5;
                        setfillcolor(RGB(base, g, base)); // äº®ç»¿è‰²æ¸å˜
                    }
                    else {
                        int gray = 200 + (shadowradius - r) * 4;
                        setfillcolor(RGB(gray, gray, gray));
                    }
                    solidcircle(cx, cy, r);
                }
                    setfillcolor(WHITE);
                    setlinecolor(BLACK);
                    circle(cx, cy, pieceradius);//ç™½æ£‹é»‘è¾¹æ¡†
                    fillcircle(cx, cy, pieceradius);
            }
            else if (gridInfo[i][j] == obstacle) {
                for (int r = shadowradius; r > shadowradius - 8; --r) {
                    int gray = 200 + (shadowradius - r) * 4;
                    setfillcolor(RGB(gray, gray, gray));
                    solidcircle(cx, cy, r);
                }
                setfillcolor(BLUE);
                fillcircle(cx, cy, pieceradius);
                setlinecolor(BLACK);
                circle(cx, cy, pieceradius);//éšœç¢é»‘è‰²è¾¹æ¡†
            }
        }
    }
}
bool inMap(int x, int y) {
    if (x < 0 || x >= GRIDSIZE || y < 0 || y >= GRIDSIZE) {
        return false;
    }
    return true;
}
bool isPathClear(int x0, int y0, int x1, int y1) {
    int dx = x1 - x0, dy = y1 - y0;//èµ·ç‚¹åˆ°ç»ˆç‚¹çš„ä½ç½®å¢é‡
    int step_x = (dx == 0) ? 0 : (dx > 0 ? 1 : -1);
    int step_y = (dy == 0) ? 0 : (dy > 0 ? 1 : -1);//èµ·ç‚¹åˆ°ç»ˆç‚¹çš„å•ä½æ­¥é•¿
    if (dx != 0 && dy != 0 && abs(dx) != abs(dy)) return false; // ä¸æ˜¯ç›´çº¿æˆ–æ–œçº¿
    int steps = max(abs(dx), abs(dy));//èµ·ç‚¹åˆ°ç»ˆç‚¹èµ°çš„æœ€å¤šæ­¥æ•°
    for (int i = 1; i < steps; ++i) {
        int nx = x0 + step_x * i;
        int ny = y0 + step_y * i;
        if (!inMap(nx, ny) || gridInfo[nx][ny] != 0) return false;
    }
    return true;
}
bool legal(int x0, int y0, int x1, int y1, int x2, int y2, int color) {
    if (!inMap(x0, y0) || !inMap(x1, y1) || !inMap(x2, y2))return false;
    if (gridInfo[x1][y1] != 0)return false;
    if (gridInfo[x0][y0] != color)return false;
    if (gridInfo[x2][y2] != 0 && !(x2 == x0 && y2 == y0))return false;
    int temp = gridInfo[x0][y0];
    gridInfo[x0][y0] = 0;
    bool path = isPathClear(x0, y0, x1, y1) && isPathClear(x1, y1, x2, y2);
    gridInfo[x0][y0] = temp;
    return path;
}
bool check_fail (int color) {
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == color) {
                for (int i = 0; i < GRIDSIZE; i++) {
                    for (int step = 1; step < GRIDSIZE; step++) {
                        int nx = x + dx[i] * step;
                        int ny = y + dy[i] * step;
                        if (!inMap(nx, ny))break;
                        else if (gridInfo[nx][ny] != 0)break;
                        else {
                            for (int adir = 0; adir < 8; adir++) {
                                for (int astep = 1; astep < GRIDSIZE; astep++) {
                                    int ax = nx + dx[adir] * astep;
                                    int ay = ny + dy[adir] * astep;
                                    if (!inMap(ax, ay)) break;
                                    else if (gridInfo[ax][ay] != 0 && (!(ax == x && ay == y)))break;//è¿™é‡Œå°„ç®­ä¹Ÿè¦å…è®¸å›åˆ°åŸä½ç½®ï¼ï¼ï¼
                                    printf("check: %d %d -> %d %d -> %d %d, gridInfo[nx][ny]=%d, gridInfo[ax][ay]=%d\n", x, y, nx, ny, ax, ay, gridInfo[nx][ny], gridInfo[ax][ay]);
                                    if (legal(x, y, nx, ny, ax, ay, color)) {
                                        printf("åˆæ³•èµ°æ³•: %d %d -> %d %d -> %d %d\n", x, y, nx, ny, ax, ay);
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (color == 1) {
        MessageBox(GetHWnd(), _T("ç™½æ£‹èƒœåˆ©ï¼"), _T("æ¸¸æˆç»“æŸ"), MB_OK | MB_ICONINFORMATION);
    }
    else {
        MessageBox(GetHWnd(), _T("é»‘æ£‹èƒœåˆ©ï¼"), _T("æ¸¸æˆç»“æŸ"), MB_OK | MB_ICONINFORMATION);
    }
    return true;
}
bool ProcStep(int x0, int y0, int x1, int y1, int x2, int y2,
    int color, bool check_only)
{
    if (!legal(x0, y0, x1, y1, x2, y2, color))return false;
    if (!check_only)
    {
        gridInfo[x0][y0] = 0;
        gridInfo[x1][y1] = color;
        gridInfo[x2][y2] = obstacle;
    }
    return true;
}
void saveGame(const string& filename) {
    ofstream fout(filename, ios::binary); // æ‰“å¼€æ–‡ä»¶ï¼Œå‡†å¤‡å†™å…¥
    if (!fout) {
        MessageBox(GetHWnd(), _T("æ–‡ä»¶ä¿å­˜å¤±è´¥ï¼"), _T("é”™è¯¯"), MB_OK | MB_ICONERROR);
        return;
    }
    fout.write((char*)gridInfo, sizeof(gridInfo)); // å†™å…¥æ£‹ç›˜
    fout.write((char*)&currentcolor, sizeof(currentcolor)); // å†™å…¥å½“å‰é¢œè‰²
    fout.write((char*)&mycolor, sizeof(mycolor));  //å†™å…¥ç©å®¶é¢œè‰²
    fout.close(); // å…³é—­æ–‡ä»¶
    MessageBox(GetHWnd(), _T("æ–‡ä»¶å·²ä¿å­˜ï¼"), _T("æç¤º"), MB_OK | MB_ICONINFORMATION);// å†™å…¥ç©å®¶é¢œè‰²
}
void loadGame(const string& filename) {
    ifstream fin(filename, ios::binary); // æ‰“å¼€æ–‡ä»¶ï¼Œå‡†å¤‡è¯»å–
    if (!fin) {
        MessageBox(GetHWnd(), _T("æ–‡ä»¶è¯»å–å¤±è´¥ï¼"), _T("é”™è¯¯"), MB_OK | MB_ICONERROR);
        return;
    }
    fin.read((char*)gridInfo, sizeof(gridInfo)); // è¯»å›æ£‹ç›˜
    fin.read((char*)&currentcolor, sizeof(currentcolor)); // è¯»å›å½“å‰é¢œè‰²
    fin.read((char*)&mycolor, sizeof(mycolor));   
    // è¯»å›ç©å®¶é¢œè‰²
    fin.close(); // å…³é—­æ–‡ä»¶
    MessageBox(GetHWnd(), _T("æ–‡ä»¶å·²è¯»å–ï¼"), _T("æç¤º"), MB_OK | MB_ICONINFORMATION);
}
void humanMove() {
    int x0=0, y0=0, x1=0, y1=0, x2=0, y2=0;
    legalmove.clear();
    legalarrow.clear();
    //é€‰æ£‹å­
    while (1) {
        ExMessage msg;
        int f = 0;
        while (peekmessage(&msg, EX_MOUSE|EX_KEY)) {
            if (msg.message == WM_MOUSEMOVE) {
                int row = (msg.y - BOARD_Y) / CELL_SIZE;
                int col = (msg.x - BOARD_X) / CELL_SIZE;
                if (inMap(row, col)&&gridInfo[row][col]==currentcolor) {
                    hoverr = row;
                    hoverc = col; 
                    cleardevice();
                    drawChessBoard();
                    drawPieces();
                }
                //æ¯æ¬¡ç»è¿‡åˆæ³•æ£‹å­ï¼Œæ›´æ–°hoverrå’Œhoverc,è°ƒç”¨drawboardï¼Œåˆ·æ–°æ£‹ç›˜
                //è¿™é‡Œå®ç°äººç±»é¼ æ ‡æ‚¬åœçš„ä½ç½®æ£‹å­ç»¿è‰²é«˜äº®
            }
            // æ–°å¢ï¼šSé”®å­˜ç›˜ï¼ŒRé”®è¯»ç›˜ï¼ŒESCç»“æŸæ¸¸æˆ
              // å­˜ç›˜ï¼šæŒ‰ä¸‹Sé”®
            if (msg.message == WM_KEYDOWN && (msg.vkcode == 'S' || msg.vkcode == 's')) {
                saveGame("amazons.sav");
                MessageBox(GetHWnd(), _T("æ¸¸æˆå·²ä¿å­˜ï¼"), _T("æç¤º"), MB_OK);
            }
            // è¯»ç›˜ï¼šæŒ‰ä¸‹Ré”®
            if (msg.message == WM_KEYDOWN && (msg.vkcode == 'R' || msg.vkcode == 'r')) {
                loadGame("amazons.sav");
                cleardevice();
                drawChessBoard();
                drawPieces();
            }
            if (msg.message == WM_KEYDOWN && msg.vkcode == VK_ESCAPE) {
                closegraph();
                exit(0);
            }
            if (msg.message == WM_LBUTTONDOWN) {
                int row = (msg.y - BOARD_Y) / CELL_SIZE;
                int col = (msg.x - BOARD_X) / CELL_SIZE;
                printf("ç‚¹å‡»: x=%d y=%d row=%d col=%d inMap=%d gridInfo=%d currentcolor=%d\n",
                msg.x, msg.y, row, col, inMap(row, col), inMap(row, col) ? gridInfo[row][col] : -99, currentcolor);
                if (inMap(row, col) && gridInfo[row][col] == currentcolor) {
                    printf("é€‰ä¸­æ£‹å­: row=%d col=%d\n", row, col);
                    x0 = row;
                    y0 = col;
                    f = 1;
                    break;
                }
            }
        }
        if (f) break;
    }
    for (int dir = 0; dir < 8; dir++) {
        for (int step = 1; step < GRIDSIZE; step++) {
            int nx = x0 + dx[dir] * step;
            int ny = y0 + dy[dir] * step;
            if (!inMap(nx, ny) || gridInfo[nx][ny] != 0) break;
            legalmove.push_back({ nx, ny });
        }
    }
    cleardevice();
    drawChessBoard();
    drawPieces();
    // é€‰ç›®æ ‡æ ¼
    while (true) {
        ExMessage msg;
        int f = 0;
        while (peekmessage(&msg, EX_MOUSE | EX_KEY)) {
            // æ–°å¢ï¼šå³é”®å­˜ç›˜ï¼ŒESCç»“æŸæ¸¸æˆ
            if (msg.message == WM_RBUTTONDOWN) {
                saveGame("amazons.sav");
                MessageBox(GetHWnd(), _T("æ¸¸æˆå·²ä¿å­˜ï¼"), _T("æç¤º"), MB_OK);
            }
            if (msg.message == WM_KEYDOWN && msg.vkcode == VK_ESCAPE) {
                closegraph();
                exit(0);
            }
            if (msg.message == WM_LBUTTONDOWN) {
                int row = (msg.y - BOARD_Y) / CELL_SIZE;
                int col = (msg.x - BOARD_X) / CELL_SIZE;
                if (inMap(row, col) && gridInfo[row][col] == 0&&isPathClear(x0,y0,row,col)) {
                    x1 = row; 
                    y1 = col;
                    destx = row;
                    desty = col;
                    f = 1;
                    cout << "é€‰ä¸­ä½ç½®ï¼šrow=" << row << " col=" << col << endl;
                    break;
                }
            }
        }
        if (f)break;
    }
    for (int i = 0; i < 8; i++) {
        for (int step = 0; step < 8; step++) {
            int ax = x1 + dx[i] * step;
            int ay = y1 + dy[i] * step;
            if (!inMap(ax, ay) || (gridInfo[ax][ay] != 0) && (ax != x0 && ay != y0))break;
            if (legal(x0, y0, x1, y1, ax, ay, currentcolor)) {
                legalarrow.push_back({ ax,ay });
            }
        }
    }
    legalmove.clear();
    cleardevice();
    drawChessBoard();
    drawPieces();
    //é€‰å°„ç®­
    while (true) {
        ExMessage msg;
        int f = 0;
        while (peekmessage(&msg, EX_MOUSE | EX_KEY)) {
            // æ–°å¢ï¼šå³é”®å­˜ç›˜ï¼ŒESCç»“æŸæ¸¸æˆ
            if (msg.message == WM_RBUTTONDOWN) {
                saveGame("amazons.sav");
                MessageBox(GetHWnd(), _T("æ¸¸æˆå·²ä¿å­˜ï¼"), _T("æç¤º"), MB_OK);
            }
            if (msg.message == WM_KEYDOWN && msg.vkcode == VK_ESCAPE) {
                closegraph();
                exit(0);
            }
            if (msg.message == WM_LBUTTONDOWN) {
                int row = (msg.y - BOARD_Y) / CELL_SIZE;
                int col = (msg.x - BOARD_X) / CELL_SIZE;
                if (inMap(row, col) && (gridInfo[row][col] == 0||(row==x0&&col==y0) )&& legal(x0, y0, x1, y1, row, col, currentcolor)&&!(row==x1&&col==y1)) {
                    x2 = row;
                    y2 = col;
                    f = 1;
                    cout << "é€‰ä¸­å°„ç®­ï¼š row=" << row << " col=" << col << endl;
                    break;
                }
            }
        }
        if (f&&ProcStep(x0, y0, x1, y1, x2, y2, currentcolor, false)) {
            break;
        }
    }
    legalarrow.clear();
    cleardevice();
    drawChessBoard();
    drawPieces();
    return;
}
int mobility(int color) {
    int cnt = 0;
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == color) {
                for (int dir = 0; dir < 8; dir++) {
                    for (int step = 1; step < GRIDSIZE; step++) {
                        int nx = x + dx[dir] * step;
                        int ny = y + dy[dir] * step;
                        if (!inMap(nx, ny)) break;
                        if (gridInfo[nx][ny] != 0) break;
                        // å°„ç®­
                        for (int adir = 0; adir < 8; adir++) {
                            for (int astep = 1; astep < GRIDSIZE; astep++) {
                                int ax = nx + dx[adir] * astep;
                                int ay = ny + dy[adir] * astep;
                                if (!inMap(ax, ay)) break;
                                if (gridInfo[ax][ay] != 0 && !(ax == x && ay == y)) break;
                                // åˆ¤æ–­å®Œæ•´åˆæ³•æ€§
                                // è¿™é‡Œç”¨å½“å‰colorï¼Œä¸å½±å“ä¸»æµç¨‹
                                if (legal(x, y, nx, ny, ax, ay, color)) {
                                    cnt++;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return cnt;
}
//æœ‰é—®é¢˜çš„minimax
//int maxdepth = 2;
//int minimax(int color,int alpha, int beta,int depth) {
//    printf("%d\n", depth);
//    if (check_fail(color)) return -1e9;
//    if (check_fail(-color)) return 1e9;
//    if (depth == maxdepth)return mobility(color) - mobility(-color);
//    if (color == currentcolor) {
//        for (int x = 0; x < GRIDSIZE; x++) {
//            for (int y = 0; y < GRIDSIZE; y++) {
//                if (gridInfo[x][y] ==color) {
//                    for (int dir = 0; dir < 8; dir++) {
//                        for (int step = 1; step <8; step++) {
//                            int nx = x + dx[dir] * step;
//                            int ny = y + dy[dir] * step;
//                            if (!inMap(nx, ny)) break;
//                            if (gridInfo[nx][ny] != 0) break;
//                            // å°„ç®­
//                            for (int adir = 0; adir < 8; adir++) {
//                                for (int astep = 1; astep < 8; astep++) {
//                                    int ax = nx + dx[adir] * astep;
//                                    int ay = ny + dy[adir] * astep;
//                                    if (!inMap(ax, ay)) break;
//                                    if (gridInfo[ax][ay] != 0 && !(ax == x && ay == y)) break;
//                                    // åˆ¤æ–­å®Œæ•´åˆæ³•æ€§
//                                    // è¿™é‡Œç”¨å½“å‰colorï¼Œä¸å½±å“ä¸»æµç¨‹
//                                    if (legal(x, y, nx, ny, ax, ay, color)) {
//                                        int backup[GRIDSIZE][GRIDSIZE];
//                                        memcpy(backup,gridInfo, sizeof(gridInfo));
//                                        ProcStep(x, y, nx, ny, ax, ay, color,false);
//                                        int score = minimax(-color, alpha, beta, depth + 1);
//                                        alpha = max(score, alpha);
//                                        memcpy(gridInfo, backup, sizeof(backup));
//                                        if (alpha >= beta)break;
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//            }
//        }
//        return alpha;
//    }
//    else {
//        for (int x = 0; x < GRIDSIZE; x++) {
//            for (int y = 0; y < GRIDSIZE; y++) {
//                if (gridInfo[x][y] == -color) {
//                    for (int dir = 0; dir < 8; dir++) {
//                        for (int step = 1; step < 8; step++) {
//                            int nx = x + dx[dir] * step;
//                            int ny = y + dy[dir] * step;
//                            if (!inMap(nx, ny)) break;
//                            if (gridInfo[nx][ny] != 0) break;
//                            // å°„ç®­
//                            for (int adir = 0; adir < 8; adir++) {
//                                for (int astep = 1; astep < 8; astep++) {
//                                    int ax = nx + dx[adir] * astep;
//                                    int ay = ny + dy[adir] * astep;
//                                    if (!inMap(ax, ay)) break;
//                                    if (gridInfo[ax][ay] != 0 && !(ax == x && ay == y)) break;
//                                    // åˆ¤æ–­å®Œæ•´åˆæ³•æ€§
//                                    // è¿™é‡Œç”¨å½“å‰colorï¼Œä¸å½±å“ä¸»æµç¨‹
//                                    if (legal(x, y, nx, ny, ax, ay, -color)) {
//                                        int backup[GRIDSIZE][GRIDSIZE];
//                                        memcpy(backup, gridInfo, sizeof(gridInfo));
//                                        ProcStep(x, y, nx, ny, ax, ay, -color, false);
//                                        int score = minimax(-color, alpha, beta, depth + 1);
//                                        beta = min(score, beta);
//                                        memcpy(gridInfo, backup, sizeof(backup));
//                                        if (beta <= alpha)break;
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//            }
//        }
//        return beta;
//    }
//    //if(depth=maxdepth)return mylegalmovecount;
//    // if(alpha>=beta)return;
//    //if(currentplayer is me){
//    //     for(my legal move){
//    // apply move;
//    // alpha=max(minimax(-s,alpha,beta),alpha);
//    // }
//    // else {
//    // for(opponentlegal move){
//    // apply move;
//    // beta=min(beta,minimax(-s,alpha,beta))
//    // }
////   }
//}
void aiMove() {
    struct Move { int x0, y0, x1, y1, x2, y2; };
    vector<Move> bestmoves;
    int bestscore = -1e9;
    int backup[GRIDSIZE][GRIDSIZE];
    int color = currentcolor;
    for (int x = 0; x < GRIDSIZE; x++) {
        for (int y = 0; y < GRIDSIZE; y++) {
            if (gridInfo[x][y] == color) {
                for (int dir = 0; dir < 8; dir++) {
                    for (int step = 1; step < GRIDSIZE; step++) {
                        int nx = x + dx[dir] * step;
                        int ny = y + dy[dir] * step;
                        if (!inMap(nx, ny)) break;
                        else if (gridInfo[nx][ny] != 0) break;
                        for (int adir = 0; adir < 8; adir++) {
                            for (int astep = 1; astep < GRIDSIZE; astep++) {
                                int ax = nx + dx[adir] * astep;
                                int ay = ny + dy[adir] * astep;
                                if (!inMap(ax, ay)) break;
                                else if (gridInfo[ax][ay] != 0 && !(ax == x && ay == y)) break;
                                if (legal(x, y, nx, ny, ax, ay, color)) {
                                    memcpy(backup, gridInfo, sizeof(gridInfo));
                                    ProcStep(x, y, nx, ny, ax, ay, color, false);
                                    int score = mobility(color) - mobility(-color);
                                    memcpy(gridInfo, backup, sizeof(gridInfo));
                                   /* int score = minimax(-color, -1e9,1e9,1);*/
                                    if (score > bestscore) {
                                        bestscore = score;
                                        bestmoves.clear();
                                        bestmoves.push_back({ x, y, nx, ny, ax, ay });
                                    }
                                    else if (score == bestscore) {
                                        bestmoves.push_back({ x, y, nx, ny, ax, ay });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (!bestmoves.empty()) {
        Move m = bestmoves[rand() % bestmoves.size()];
        ProcStep(m.x0, m.y0, m.x1, m.y1, m.x2, m.y2, color, false);
        cleardevice();
        drawChessBoard();
        drawPieces();
        stringstream ss;
        ss << "AI move: " << m.x0 << " " << m.y0 << " " << m.x1 << " " << m.y1 << " " << m.x2 << " " << m.y2;
        string s = ss.str();
        cout << "AIèµ°æ­¥ï¼š" << s << endl;
        wstring ws(s.begin(), s.end());
        outtextxy(0, 0, ws.c_str());
    }
    return;
}
void initBoard() {
    memset(gridInfo, 0, sizeof(gridInfo));
    gridInfo[0][(GRIDSIZE - 1) / 3] = gridInfo[(GRIDSIZE - 1) / 3][0]
        = gridInfo[GRIDSIZE - 1 - ((GRIDSIZE - 1) / 3)][0]
        = gridInfo[GRIDSIZE - 1][(GRIDSIZE - 1) / 3] = grid_black;
    gridInfo[0][GRIDSIZE - 1 - ((GRIDSIZE - 1) / 3)] = gridInfo[(GRIDSIZE - 1) / 3][GRIDSIZE - 1]
        = gridInfo[GRIDSIZE - 1 - ((GRIDSIZE - 1) / 3)][GRIDSIZE - 1]
        = gridInfo[GRIDSIZE - 1][GRIDSIZE - 1 - ((GRIDSIZE - 1) / 3)] = grid_white;
}
int main() {
    srand((unsigned)time(0)); // åªéœ€åœ¨mainé‡Œè°ƒç”¨ä¸€æ¬¡å³å¯
    initBoard(); 
    initgraph(600, 600); 
    cleardevice();
    setbkcolor(RGB(128, 128, 128));
    drawbackground();
    drawmenu(hoverbutton);
    while (1) {
        int x = selectmenu();
        if (x == 0) {
            cleardevice();
            outtextxy(80,200, icons[0].c_str());
            outtextxy(80, 300, icons[0].c_str());
            settextstyle(40, 0, _T("å¾®è½¯é›…é»‘"));
            wstring ws1 = L"ç‚¹å‡»å±å¹•å·¦ä¾§æ‰§é»‘";
            wstring ws2 =L"ç‚¹å‡»å±å¹•å³ä¾§æ‰§ç™½";
            outtextxy(100, 200, ws1.c_str());
            outtextxy(100, 300, ws2.c_str());
            while (1) {
                ExMessage msg;
                if (peekmessage(&msg, EM_MOUSE)) {
                    if (msg.message == WM_LBUTTONDOWN) {
                        if (msg.x < 300) {
                            mycolor = 1;
                            MessageBox(GetHWnd(), _T("ä½ é€‰æ‹©äº†é»‘æ£‹"), _T("æç¤º"), MB_OK);
                            currentcolor = mycolor;
                            cleardevice();
                            drawChessBoard();
                            drawPieces();
                            break;
                        }
                        else {
                            mycolor = -1;
                            MessageBox(GetHWnd(), _T("ä½ é€‰æ‹©äº†ç™½æ£‹"), _T("æç¤º"), MB_OK);
                            currentcolor = mycolor;
                            cleardevice();
                            drawChessBoard();
                            drawPieces();
                            break;
                        }
                    }
                }
            }
            break;
        }
        else if (x== 1){
            loadGame("amazons.sav");
            cleardevice();
            drawChessBoard();
            drawPieces();
            break;
        }
        else if (x == 2) {
            closegraph();
            exit(0);
        }
    }
    while (true) {
            // ç©å®¶å›åˆ
            currentcolor = mycolor;
            if (check_fail(currentcolor))break;
            humanMove();
             // AIå›åˆ
            currentcolor = -1 * mycolor;
            if (check_fail(currentcolor))break;
            aiMove();
    }
    closegraph();
}
